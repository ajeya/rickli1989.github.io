{"version":3,"sources":["app/widget/Util.js"],"names":[],"mappings":"AAAA,OAAO,SAAS,IAAI,UAAU,SAAS;IACnC;;IAEA,QAAQ,YAAY;;IAAjB,SAAS,SAAS,SAAS;;QAE9B,IAAI,MAAM,QAAQ,OAAO;;QAEzB,OAAO;YACH,WAAW;YACX,YAAY;YACZ,SAAS;YACT,UAAU;YACV,SAAS;;;QAGb,SAAS,UAAU,MAAM,eAAe;;YAEpC,gBAAgB,sBAAsB;;YAEtC,IAAI,CAAC,cAAc,UAAU,SAAS;gBAElC,cAAc,UAAU,UAAU,YAAM;;;YAG5C,IAAI,oBAAoB,eAAe,cAAc,UAAU;;YAM/D,UAAU,cAAc,WAAW,WAAW,YAAY;gBACtD,OAAO,YAAY;oBACf,kBAAkB,MAAM,MAAM;;oBAE9B,IAAI,cAAc,UAAU,MAAM;wBAC9B,OAAO,cAAc,UAAU,KAAK,KAAK;;;;;YAKrD,IAAI,eAAe,oBAAoB;;YAEvC,IAAI,UAAU,MAAM;YACpB,OAAO;;;QAGX,SAAS,WAAW,MAAM,cAAc;YACpC,IAAI,WAAW,MAAM;YACrB,OAAO;;;QAGX,SAAS,QAAQ,MAAM,cAAc;YACjC,IAAI,QAAQ,MAAM;YAClB,OAAO;;;QAGX,SAAS,SAAS,MAAM,eAAe;YACnC,IAAI,SAAS,MAAM;YACnB,OAAO;;;QAGX,SAAS,QAAQ,MAAM,eAAe;YAClC,gBAAgB,sBAAsB;YACtC,IAAI,eAAe,oBAAoB;YACvC,IAAI,QAAQ,MAAM;YAClB,OAAO;;;QAWX,SAAS,sBAAsB,OAAO;YAClC,IAAI;;YAEJ,IAAI,MAAM,gBAAgB,OAAO;gBAE7B,IAAI,WAAW,MAAM,MAAM,GAAG,MAAM,SAAS;gBAC7C,gBAAgB,MAAM,MAAM,SAAS;gBACrC,cAAc,UAAU;mBACrB;gBACH,gBAAgB;;;YAGpB,OAAO;;;QAcX,SAAS,oBAAoB,eAAe;YAExC,IAAI,OAAO,cAAc,WAAW;YACpC,IAAI,eAAe,KAAK;YAGxB,aAAa,KAAK,YAAa;gBAzBvB,KAAK,IAAI,OAAO,UAAU,QAyBZ,OAAI,MAAA,OAAA,OAAA,GAAA,OAAA,MAAA,QAAA;oBAAJ,KAAI,QAAA,UAAA;;;gBAEtB,IAAI,WAAQ,KAAA,aAAA,KAAA,MAAO,eAAa,CAAA,MAAA,OAAI;gBACpC,KAAK,IAAI,OAAO,UAAU;oBACtB,SAAS,OAAO,SAAS;;gBAE7B,OAAO;;;YAGX,OAAO;;;QAQX,SAAS,eAAe,UAAU;YAC9B,OAAO,YAAW;gBACd,OAAO,SAAS,MAAM,MAAM;;;;QAUpC,SAAS,UAAU,QAAQ,YAAY,UAAU;YAC7C,OAAO,cAAc,SAAS,OAAO;;;;IA9BzC,OAAO;QACH,SAAS;QACT,SAAS,YAAY;;GAE1B","file":"app/widget/Util.js","sourcesContent":["/**\n * A helper class to simplify registering Angular components and provide a consistent syntax for doing so.\n */\nexport function register(appName) {\n\n    var app = angular.module(appName);\n\n    return {\n        directive: directive,\n        controller: controller,\n        service: service,\n        provider: provider,\n        factory: factory\n    };\n\n    function directive(name, constructorFn) {\n\n        constructorFn = _normalizeConstructor(constructorFn);\n\n        if (!constructorFn.prototype.compile) {\n            // create an empty compile function if none was defined.\n            constructorFn.prototype.compile = () => {};\n        }\n\n        var originalCompileFn = _cloneFunction(constructorFn.prototype.compile);\n\n        // Decorate the compile method to automatically return the link method (if it exists)\n        // and bind it to the context of the constructor (so `this` works correctly).\n        // This gets around the problem of a non-lexical \"this\" which occurs when the directive class itself\n        // returns `this.link` from within the compile function.\n        _override(constructorFn.prototype, 'compile', function () {\n            return function () {\n                originalCompileFn.apply(this, arguments);\n\n                if (constructorFn.prototype.link) {\n                    return constructorFn.prototype.link.bind(this);\n                }\n            };\n        });\n\n        var factoryArray = _createFactoryArray(constructorFn);\n\n        app.directive(name, factoryArray);\n        return this;\n    }\n\n    function controller(name, contructorFn) {\n        app.controller(name, contructorFn);\n        return this;\n    }\n\n    function service(name, contructorFn) {\n        app.service(name, contructorFn);\n        return this;\n    }\n\n    function provider(name, constructorFn) {\n        app.provider(name, constructorFn);\n        return this;\n    }\n\n    function factory(name, constructorFn) {\n        constructorFn = _normalizeConstructor(constructorFn);\n        var factoryArray = _createFactoryArray(constructorFn);\n        app.factory(name, factoryArray);\n        return this;\n    }\n\n    /**\n     * If the constructorFn is an array of type ['dep1', 'dep2', ..., constructor() {}]\n     * we need to pull out the array of dependencies and add it as an $inject property of the\n     * actual constructor function.\n     * @param input\n     * @returns {*}\n     * @private\n     */\n    function _normalizeConstructor(input) {\n        var constructorFn;\n\n        if (input.constructor === Array) {\n            //\n            var injected = input.slice(0, input.length - 1);\n            constructorFn = input[input.length - 1];\n            constructorFn.$inject = injected;\n        } else {\n            constructorFn = input;\n        }\n\n        return constructorFn;\n    }\n\n    /**\n     * Convert a constructor function into a factory function which returns a new instance of that\n     * constructor, with the correct dependencies automatically injected as arguments.\n     *\n     * In order to inject the dependencies, they must be attached to the constructor function with the\n     * `$inject` property annotation.\n     *\n     * @param constructorFn\n     * @returns {Array.<T>}\n     * @private\n     */\n    function _createFactoryArray(constructorFn) {\n        // get the array of dependencies that are needed by this component (as contained in the `$inject` array)\n        var args = constructorFn.$inject || [];\n        var factoryArray = args.slice(); // create a copy of the array\n        // The factoryArray uses Angular's array notation whereby each element of the array is the name of a\n        // dependency, and the final item is the factory function itself.\n        factoryArray.push((...args) => {\n            //return new constructorFn(...args);\n            var instance = new constructorFn(...args);\n            for (var key in instance) {\n                instance[key] = instance[key];\n            }\n            return instance;\n        });\n\n        return factoryArray;\n    }\n\n    /**\n     * Clone a function\n     * @param original\n     * @returns {Function}\n     */\n    function _cloneFunction(original) {\n        return function() {\n            return original.apply(this, arguments);\n        };\n    }\n\n    /**\n     * Override an object's method with a new one specified by `callback`.\n     * @param object\n     * @param methodName\n     * @param callback\n     */\n    function _override(object, methodName, callback) {\n        object[methodName] = callback(object[methodName])\n    }\n\n}"],"sourceRoot":"/source/"}